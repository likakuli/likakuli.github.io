# AI开始写代码了，程序员该做什么？


# **AI开始写代码了，程序员该做什么？**

> 从编写每一行代码，到为 AI 编写"作战条例"，一场静默的变革正在发生

深夜，屏幕上闪烁的光标前，最后一段由 AI 生成的代码通过了测试。本该松一口气的时刻，我却感到一丝不安——这已经是本周第 N 次，由 AI 生成的代码，虽然功能完美运行，但风格却迥然不同，仿佛精神分裂患者。

这正是我们正在经历的现实：**AI 编码工具在带来 N 倍效率提升的同时，也正在颠覆我们对"编程"这件事的认知。**

## **一、效率的狂欢与隐忧** 

当我们用自然语言描述需求，几分钟内就能得到一个可运行的功能模块时，那种"魔法般"的体验令人着迷。在探索新想法、构建原型或编写独立函数时，AI 编码展现出无与伦比的速度优势。

然而，当我们将视线投向需要**长期维护、多人协作的生产级系统**时，魔法开始显露出它的另一面。

**首先是代码的"概率性"困境。** 即便使用完全相同的提示词，不同 AI 模型、甚至同一模型的不同调用，都可能产出结构迥异的代码。在团队协作中，这直接导致了代码库的"熵增"——系统会随着时间推移变得越来越难以理解和维护。

**其次是指令的"罗生门"效应。** 复杂的需求描述如同一段需要解读的文本，不同开发者给出的提示词必然存在差异，导致最终代码实现五花八门。当需要基于他人 AI 生成的代码进行迭代时，理解成本可能远高于从头编写。

## **二、Rule：对抗混乱的"编码宪法"** 

问题的核心在于：**如何让概率性的 AI 输出，符合工程对确定性的要求？**

答案或许就藏在项目根目录下一个看似普通的文件夹中：`.cursor/rules`。

**Rule（规则），本质上是机器可读、可执行的团队编码规范。** 它可以规定"所有 API 响应必须包裹在标准结构体中"、"错误码必须来自集中枚举类"、"日志必须使用 SLF4J 接口"等等。

这带来了两个根本改变：

1. **从"口头规范"到"自动执行"**：编码规范不再依赖文档和记忆，而是成为了代码生成流程中自动执行的一部分。
2. **从"风格随机"到"输出一致"**：AI 的产出被约束在团队约定的范式内，代码质量变得可预测、可管理。

### **实践中的 Rule：三层防护网**

理想的 Rule 体系应该像一套标准化的"集装箱"，层层嵌套，确保从基础语法到业务逻辑的一致性：

- **基础层（语言/生态 Rule）**：如 `rule-preset-python`、`rule-preset-go`。它解决的是生态共性问题，比如 Python 的命名规范、Go 的错误处理模式。**这一层应由语言社区或开源基金会主导**，形成广泛接受的事实标准。
- **中间层（框架/领域 Rule）**：如 `rule-for-react`、`rule-for-spring-boot`。它定义了在使用特定框架或中间件时的最佳实践和架构约束。**这一层理应由该框架的活跃社区或核心维护者来定义和维护**，确保 SDK 使用者能生成"地道"的代码。
- **应用层（团队/业务 Rule）**：这是团队独有的"军规"，固化着内部的业务约定、历史包袱和特定习惯。**这一层由团队自己创造和积累**，是核心竞争力所在。

**每一次代码评审，都是提炼 Rule 的绝佳时机。** 当发现 AI 生成的代码不符合规范时，当场就将这条规范转化为具体的 Rule。新成员通过阅读这些 Rule 文件，能比阅读陈旧的 Wiki 更快地理解"我们团队是怎么做事的"。

## **三、从"棋手"到"教练"，终将走向"赛事设计师"** 

当 AI 承担了越来越多"实现"的工作，开发者的角色正在发生一场静默但深刻的迁徙：

**过去，我们是"棋手"**——需要深思每一步落子（每一行代码），胜负系于个人的精妙算力。

**现在，我们正在成为"教练"\**——不再亲自下场，而是制定战术（Rule）、分析对手（需求）、指导队员（AI）执行。我们的核心能力变成了\**制定清晰、可执行的"战术手册"\**和\**临场指挥调整**。

**未来，我们可能成为"赛事设计师"**——定义比赛规则（业务规格与架构）、组建团队（调度不同的 AI Agent）、管理资源，确保整个体系持续、稳定地产出价值。

## **四、务实者的路径：从"Docker"到"Kubernetes"** 

面对 AI 编程，业界涌现了许多宏大概念，如 **SDD（Specification-Driven Development，规范驱动开发）**。其理想很美好：先编写机器可读的精确"规格"，再由 AI 自动生成所有代码、测试和文档。

然而，试图一次性重构整个开发流程，难度犹如在泥泞地基上建造摩天大楼。一个更务实的路径是**自下而上的演进**。

我们可以借用容器生态的演变来理解：

- **Rule 如同 Docker/CRI**：它定义了**AI 编码的"最小可交付单元"的标准**。就像 Docker 镜像封装了应用与环境，Rule 封装了代码的生成规范，确保输出的一致性。
- **SDD 则如同 Kubernetes**：它旨在定义**如何调度、编排、验证这些"标准单元"以完成复杂任务**。这是一个更高层次的"编排"系统。

历史告诉我们，**没有成熟的容器镜像（Rule）生态，Kubernetes（SDD）便无从谈起**。因此，当下的重点不是空谈宏大的"编排"架构，而是全力建设"标准化"的基础设施。

### **当下的行动建议：**

1. **立即开始积累团队的"Rule 镜像仓库"**：像积累 Docker 镜像一样，从最痛的代码规范点开始，为你的项目积累高质量、可复用的 Rule。
2. **在流程中植入"微编排"思维**：在复杂任务中，实践"规划-执行-验证"的循环。让 AI 先出方案（规划），你来审核（调度决策），再让它分步执行（启动容器），最后你验证结果（健康检查）。这就是手动的、小规模的"SDD"。
3. **关注"编排"协议的萌芽**：关注如 **MCP（Model Context Protocol）** 等协议的发展，它们正试图标准化 AI 与工具、上下文的交互方式，为未来的自动化协作铺路。这比追逐"SDD"概念本身更有意义。

## **五、未来已来：思考"为何而编程"** 

真正的危险不是被 AI 取代，而是**错过与 AI 协同进化的机会**。

那些能够驾驭 AI、善用 AI 的程序员，将在这次技术变革中获得前所未有的发展机遇。他们懂得 **"战术上借力，战略上专注"\**——将重复性、确定性的"语法劳动"交给 AI，自己则专注于创造性的"语义创造"：即\**定义问题、设计架构、制定规则与验收成果**。

**AI 不会淘汰程序员，但会使用 AI 的程序员会淘汰不会使用 AI 的程序员。**

我们的工作价值正不可逆转地向价值链上游迁移。

## **写在最后** 

回到开头的那个深夜，当我开始为团队编写第一条 `.cursor/rules` 时，我突然明白：**我们不是在教 AI 写代码，而是在定义一种新的、人机协同的"编程语言"。**

这种语言，既能让机器高效执行，又能让人类清晰理解。它的词汇是约束条件，它的语法是设计模式，它的篇章是软件架构。

这场从"编码者"到"指挥官"的进化已悄然启程。而你的起点，或许就是从为你的下一个项目，创建第一条 Rule 开始。

------

**在这个代码可以自动生成的时代，思考"为何而编程"，比思考"如何编程"更加重要。**


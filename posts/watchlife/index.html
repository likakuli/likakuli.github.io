<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>一条 Watch 请求的一生 - kaku&#39;s blog</title><meta name="Description" content="一亩三分自留地"><meta property="og:title" content="一条 Watch 请求的一生" />
<meta property="og:description" content="Watch 请求像极了打工人的一生，从加入社会（cacher.watchers）开始就不停地被 Push，拼命的干，干的慢了就有可能会被干掉，干的快的奖" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://www.likakuli.com/posts/watchlife/" /><meta property="og:image" content="https://www.likakuli.com/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-23T22:44:37+08:00" />
<meta property="article:modified_time" content="2023-12-27T22:32:04+08:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://www.likakuli.com/logo.png"/>

<meta name="twitter:title" content="一条 Watch 请求的一生"/>
<meta name="twitter:description" content="Watch 请求像极了打工人的一生，从加入社会（cacher.watchers）开始就不停地被 Push，拼命的干，干的慢了就有可能会被干掉，干的快的奖"/>
<meta name="application-name" content="LoveIt">
<meta name="apple-mobile-web-app-title" content="LoveIt"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://www.likakuli.com/posts/watchlife/" /><link rel="prev" href="https://www.likakuli.com/posts/connection/" /><link rel="next" href="https://www.likakuli.com/posts/k8sparams/" /><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "一条 Watch 请求的一生",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/www.likakuli.com\/posts\/watchlife\/"
        },"genre": "posts","keywords": "kubernetes","wordcount":  7757 ,
        "url": "https:\/\/www.likakuli.com\/posts\/watchlife\/","datePublished": "2023-12-23T22:44:37+08:00","dateModified": "2023-12-27T22:32:04+08:00","publisher": {
            "@type": "Organization",
            "name": "kaku","logo": {
                    "@type": "ImageObject",
                    "url": "https:\/\/www.likakuli.com\/images\/avatar.png",
                    "width":  528 ,
                    "height":  560 
                }},"author": {
                "@type": "Person",
                "name": "Kaku Li"
            },"description": ""
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('auto' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : 'auto' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="kaku&#39;s blog"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>kaku&#39;s blog</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 关于 </a><a class="menu-item" href="/projects/"> 项目 </a><a class="menu-item" href="/friends/"> 友链 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="kaku&#39;s blog"><span class="header-title-pre"><i class='far fa-kiss-wink-heart fa-fw'></i></span>kaku&#39;s blog</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">关于</a><a class="menu-item" href="/projects/" title="">项目</a><a class="menu-item" href="/friends/" title="">友链</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content always-active" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">一条 Watch 请求的一生</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Kaku Li</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="far fa-folder fa-fw"></i>源码分析</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2023-12-23">2023-12-23</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 7757 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 16 分钟&nbsp;<span id="/posts/watchlife/" class="leancloud_visitors" data-flag-title="一条 Watch 请求的一生">
                        <i class="far fa-eye fa-fw"></i>&nbsp;<span class=leancloud-visitors-count></span>&nbsp;次阅读
                    </span>&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li><a href="#怎么来滴">怎么来滴</a>
      <ul>
        <li><a href="#客户端">客户端</a>
          <ul>
            <li><a href="#发起请求">发起请求</a></li>
            <li><a href="#数据流">数据流</a></li>
          </ul>
        </li>
        <li><a href="#服务端">服务端</a>
          <ul>
            <li><a href="#路由">路由</a></li>
            <li><a href="#handler">Handler</a></li>
            <li><a href="#数据流-1">数据流</a></li>
            <li><a href="#小结">小结</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#干到干不动">干到干不动</a>
      <ul>
        <li><a href="#三驾马车">三驾马车</a></li>
        <li><a href="#辛苦劳碌">辛苦劳碌</a>
          <ul>
            <li><a href="#前置过滤---cacher">前置过滤 - cacher</a></li>
            <li><a href="#控制-bookmark-频率---cacher">控制 bookmark 频率 - cacher</a></li>
            <li><a href="#及时消费">及时消费</a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#怎么没滴">怎么没滴</a></li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><blockquote>
<p>Watch 请求像极了打工人的一生，从加入社会（cacher.watchers）开始就不停地被 Push，拼命的干，干的慢了就有可能会被干掉，干的快的奖励干到寿终正寝，就像某些专家建议的一样。</p>
</blockquote>
<p>前面已经通过一个系列来介绍 kube-apiserver cache 相关内容，本篇旨在通过分析 Watch 请求的生命周期把前面涉及到的关键内容串联起来，系统的描述在每个阶段都涉及到哪些关键内容，方便更直观的了解之前每一篇在整个过程中的位置和作用。</p>
<p>基于 v1.29 分支，针对 HTTP 协议分析（忽略 WS）。</p>
<h1 id="怎么来滴">怎么来滴</h1>
<h2 id="客户端">客户端</h2>
<h3 id="发起请求">发起请求</h3>
<p>Watch 请求本质还是 List 请求，集群中的大部分 watch 请求来自于集群内的 agent 或者 DaemonSet 类的数据面组件，比如 kubelet，kube-proxy 等，当然也可能会存在一些非 Go 语言的组件，但无论什么语言，什么组件，最终都是调用了 kube-apiserver 对应的 API 来实现的 watch。以常用的 <a href="https://mp.weixin.qq.com/s/ciEzUs5qb9WZYMl6QC8sZA" target="_blank" rel="noopener noreffer">client-go informer</a> 为例，看如下调用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">c</span><span class="p">.</span><span class="nx">client</span><span class="p">.</span><span class="nf">Get</span><span class="p">().</span>
		<span class="nf">Resource</span><span class="p">(</span><span class="s">&#34;pods&#34;</span><span class="p">).</span>
		<span class="nf">VersionedParams</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">opts</span><span class="p">,</span> <span class="nx">scheme</span><span class="p">.</span><span class="nx">ParameterCodec</span><span class="p">).</span>
		<span class="nf">Timeout</span><span class="p">(</span><span class="nx">timeout</span><span class="p">).</span>
		<span class="nf">Watch</span><span class="p">(</span><span class="nx">ctx</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><code>VersionedParams</code> 方法处理 opts（ListOptions）里面的参数并保存到 <code>request.params</code> 中，在最后调用 <code>Watch</code> 时会调用 <code>URL</code> 方法，利用 <code>request.params</code> 生成 url 的 query，最后返回完整的 url，其中 Watch: true 就是 ListOptions 的参数，最终会拼到生成的 url query 中，类似 /api/v1/pods?watch=true  的形式。</p>
<h3 id="数据流">数据流</h3>
<p>特指使用 client-go informer 时的数据流</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://www.likakuli.com/posts/informer1/informer.svg"
        data-srcset="https://www.likakuli.com/posts/informer1/informer.svg, https://www.likakuli.com/posts/informer1/informer.svg 1.5x, https://www.likakuli.com/posts/informer1/informer.svg 2x"
        data-sizes="auto"
        alt="https://www.likakuli.com/posts/informer1/informer.svg"
        title="informer" /></p>
<h2 id="服务端">服务端</h2>
<h3 id="路由">路由</h3>
<p>当客户端最终调用了 API 进行 watch，kube-apiserver 收到请求后会启动一个 goroutine 调用相应的 handler 来处理这个请求。kube-apiserver 启动时会进行路由注册，最终通过 <code>APIInstaller</code> 的 <code>registerResourceHandlers</code> 注册路由及对应的 handler，如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">a</span> <span class="o">*</span><span class="nx">APIInstaller</span><span class="p">)</span> <span class="nf">registerResourceHandlers</span><span class="p">(</span><span class="nx">path</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">storage</span> <span class="nx">rest</span><span class="p">.</span><span class="nx">Storage</span><span class="p">,</span> <span class="nx">ws</span> <span class="o">*</span><span class="nx">restful</span><span class="p">.</span><span class="nx">WebService</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="nx">metav1</span><span class="p">.</span><span class="nx">APIResource</span><span class="p">,</span> <span class="o">*</span><span class="nx">storageversion</span><span class="p">.</span><span class="nx">ResourceInfo</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>三个入参，分来是路径，后端存储，路由，每一种资源都有自己对应的 <code>Storage</code>，但所有的 <code>Storage</code> 又都包含了相同的匿名嵌套结构 <code>*genericregistry.Store</code>，而此结构实现了 Watch 接口，所以所有的 <code>Storage</code> 也就都实现了 Watch 接口。handler 注册如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">case</span> <span class="s">&#34;LIST&#34;</span><span class="p">:</span> <span class="c1">// List all resources of a kind.
</span><span class="c1"></span>			<span class="nx">doc</span> <span class="o">:=</span> <span class="s">&#34;list objects of kind &#34;</span> <span class="o">+</span> <span class="nx">kind</span>
			<span class="k">if</span> <span class="nx">isSubresource</span> <span class="p">{</span>
				<span class="nx">doc</span> <span class="p">=</span> <span class="s">&#34;list &#34;</span> <span class="o">+</span> <span class="nx">subresource</span> <span class="o">+</span> <span class="s">&#34; of objects of kind &#34;</span> <span class="o">+</span> <span class="nx">kind</span>
			<span class="p">}</span>
			<span class="nx">handler</span> <span class="o">:=</span> <span class="nx">metrics</span><span class="p">.</span><span class="nf">InstrumentRouteFunc</span><span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="nx">Verb</span><span class="p">,</span> <span class="nx">group</span><span class="p">,</span> <span class="nx">version</span><span class="p">,</span> <span class="nx">resource</span><span class="p">,</span> <span class="nx">subresource</span><span class="p">,</span> <span class="nx">requestScope</span><span class="p">,</span> <span class="nx">metrics</span><span class="p">.</span><span class="nx">APIServerComponent</span><span class="p">,</span> <span class="nx">deprecated</span><span class="p">,</span> <span class="nx">removedRelease</span><span class="p">,</span> <span class="nf">restfulListResource</span><span class="p">(</span><span class="nx">lister</span><span class="p">,</span> <span class="nx">watcher</span><span class="p">,</span> <span class="nx">reqScope</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">minRequestTimeout</span><span class="p">))</span>
			<span class="nx">handler</span> <span class="p">=</span> <span class="nx">utilwarning</span><span class="p">.</span><span class="nf">AddWarningsHandler</span><span class="p">(</span><span class="nx">handler</span><span class="p">,</span> <span class="nx">warnings</span><span class="p">)</span>
			<span class="nx">route</span> <span class="o">:=</span> <span class="nx">ws</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="nx">Path</span><span class="p">).</span><span class="nf">To</span><span class="p">(</span><span class="nx">handler</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>如果看代码的话，还能看到其他地方有 watch handler 的注册，但会标注 <code>deprecated in 1.11</code>，这些 case 分支对应的是在 uri <strong>path</strong> 中添加 watch/ 的那些请求，类似 /api/v1/pods/watch 的路径，而客户端是通过 <strong>query</strong> 传递的参数，所以最终还是命中 case List。</p>
<h3 id="handler">Handler</h3>
<p>业务逻辑在 <code>restfulListResource</code> 中，经过一层层的函数调用，最终实例化一个对应的 <code>WatchServer</code> 对象，并通过 <code>HandleHTTP</code> 来处理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// HandleHTTP serves a series of encoded events via HTTP with Transfer-Encoding: chunked.
</span><span class="c1">// or over a websocket connection.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">WatchServer</span><span class="p">)</span> <span class="nf">HandleHTTP</span><span class="p">(</span><span class="nx">w</span> <span class="nx">http</span><span class="p">.</span><span class="nx">ResponseWriter</span><span class="p">,</span> <span class="nx">req</span> <span class="o">*</span><span class="nx">http</span><span class="p">.</span><span class="nx">Request</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">flusher</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">w</span><span class="p">.(</span><span class="nx">http</span><span class="p">.</span><span class="nx">Flusher</span><span class="p">)</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;unable to start watch - can&#39;t get http.Flusher: %#v&#34;</span><span class="p">,</span> <span class="nx">w</span><span class="p">)</span>
		<span class="nx">utilruntime</span><span class="p">.</span><span class="nf">HandleError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">Scope</span><span class="p">.</span><span class="nf">err</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nf">NewInternalError</span><span class="p">(</span><span class="nx">err</span><span class="p">),</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="nx">framer</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Framer</span><span class="p">.</span><span class="nf">NewFrameWriter</span><span class="p">(</span><span class="nx">w</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">framer</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// programmer error
</span><span class="c1"></span>		<span class="nx">err</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Errorf</span><span class="p">(</span><span class="s">&#34;no stream framing support is available for media type %q&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">MediaType</span><span class="p">)</span>
		<span class="nx">utilruntime</span><span class="p">.</span><span class="nf">HandleError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
		<span class="nx">s</span><span class="p">.</span><span class="nx">Scope</span><span class="p">.</span><span class="nf">err</span><span class="p">(</span><span class="nx">errors</span><span class="p">.</span><span class="nf">NewBadRequest</span><span class="p">(</span><span class="nx">err</span><span class="p">.</span><span class="nf">Error</span><span class="p">()),</span> <span class="nx">w</span><span class="p">,</span> <span class="nx">req</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>

	<span class="c1">// ensure the connection times out
</span><span class="c1"></span>	<span class="nx">timeoutCh</span><span class="p">,</span> <span class="nx">cleanup</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">TimeoutFactory</span><span class="p">.</span><span class="nf">TimeoutCh</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nf">cleanup</span><span class="p">()</span>

	<span class="c1">// begin the stream
</span><span class="c1"></span>	<span class="nx">w</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Content-Type&#34;</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">MediaType</span><span class="p">)</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">Header</span><span class="p">().</span><span class="nf">Set</span><span class="p">(</span><span class="s">&#34;Transfer-Encoding&#34;</span><span class="p">,</span> <span class="s">&#34;chunked&#34;</span><span class="p">)</span>
	<span class="nx">w</span><span class="p">.</span><span class="nf">WriteHeader</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">StatusOK</span><span class="p">)</span>
	<span class="nx">flusher</span><span class="p">.</span><span class="nf">Flush</span><span class="p">()</span>

	<span class="nx">kind</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Scope</span><span class="p">.</span><span class="nx">Kind</span>
	<span class="nx">watchEncoder</span> <span class="o">:=</span> <span class="nf">newWatchEncoder</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">(),</span> <span class="nx">kind</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">EmbeddedEncoder</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Encoder</span><span class="p">,</span> <span class="nx">framer</span><span class="p">)</span>
	<span class="nx">ch</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Watching</span><span class="p">.</span><span class="nf">ResultChan</span><span class="p">()</span>
	<span class="nx">done</span> <span class="o">:=</span> <span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">().</span><span class="nf">Done</span><span class="p">()</span>

	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">s</span><span class="p">.</span><span class="nx">ServerShuttingDownCh</span><span class="p">:</span>
			<span class="c1">// the server has signaled that it is shutting down (not accepting
</span><span class="c1"></span>			<span class="c1">// any new request), all active watch request(s) should return
</span><span class="c1"></span>			<span class="c1">// immediately here. The WithWatchTerminationDuringShutdown server
</span><span class="c1"></span>			<span class="c1">// filter will ensure that the response to the client is rate
</span><span class="c1"></span>			<span class="c1">// limited in order to avoid any thundering herd issue when the
</span><span class="c1"></span>			<span class="c1">// client(s) try to reestablish the WATCH on the other
</span><span class="c1"></span>			<span class="c1">// available apiserver instance(s).
</span><span class="c1"></span>			<span class="k">return</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">done</span><span class="p">:</span>
			<span class="k">return</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">timeoutCh</span><span class="p">:</span>
			<span class="k">return</span>
		<span class="k">case</span> <span class="nx">event</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
				<span class="c1">// End of results.
</span><span class="c1"></span>				<span class="k">return</span>
			<span class="p">}</span>
			<span class="nx">metrics</span><span class="p">.</span><span class="nx">WatchEvents</span><span class="p">.</span><span class="nf">WithContext</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">()).</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="nx">kind</span><span class="p">.</span><span class="nx">Group</span><span class="p">,</span> <span class="nx">kind</span><span class="p">.</span><span class="nx">Version</span><span class="p">,</span> <span class="nx">kind</span><span class="p">.</span><span class="nx">Kind</span><span class="p">).</span><span class="nf">Inc</span><span class="p">()</span>
			<span class="nx">isWatchListLatencyRecordingRequired</span> <span class="o">:=</span> <span class="nf">shouldRecordWatchListLatency</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span>

			<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">watchEncoder</span><span class="p">.</span><span class="nf">Encode</span><span class="p">(</span><span class="nx">event</span><span class="p">);</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
				<span class="nx">utilruntime</span><span class="p">.</span><span class="nf">HandleError</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
				<span class="c1">// client disconnect.
</span><span class="c1"></span>				<span class="k">return</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
				<span class="nx">flusher</span><span class="p">.</span><span class="nf">Flush</span><span class="p">()</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="nx">isWatchListLatencyRecordingRequired</span> <span class="p">{</span>
				<span class="nx">metrics</span><span class="p">.</span><span class="nf">RecordWatchListLatency</span><span class="p">(</span><span class="nx">req</span><span class="p">.</span><span class="nf">Context</span><span class="p">(),</span> <span class="nx">s</span><span class="p">.</span><span class="nx">Scope</span><span class="p">.</span><span class="nx">Resource</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">metricsScope</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到 watch 是通过为 HTTP 设置 <code>Transfer-Encoding: chunked</code> 实现的，<code>s.Watching</code> 就是上面提到的 <code>Storage.(Watcher).Watch</code> 的返回结果，<code>Storage.(Watcher)</code> 就是 <code>*genericregistry.Store</code>，<code>Store</code> 结构体本身也有个叫 <code>Storage</code> 的属性，经典的 store，storage 模式，store 是服务的封装，storage 的存储的封装。最终往 response 里面写的内容是从 <code>ch := s.Watching.ResultChan()</code> 获取的，然后<a href="https://mp.weixin.qq.com/s/RrBOHRSztsnkp5M2_32VrQ" target="_blank" rel="noopener noreffer">对 Event 以及 Event 中包含的资源对象进行序列化</a>后写到最后的 response 中。</p>
<h3 id="数据流-1">数据流</h3>
<p><code>Store.Storage</code> 要么是 cacher，要么是 Etcd，由 kube-apiserver 的启动参数 <code>--watch-cache</code> 控制，默认为 true，对应 <code>Store.Storage</code> 是 cacher，这里我们只关注 cacher 的场景，最终返回的 cacheWatcher 现了 <code>k8s.io/apimachinery/pkg/watch/watch.go</code> 文件中定义的 <code>Interface</code> 接口（这个接口类型名字有点抽象）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// Watch implements storage.Interface.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cacher</span><span class="p">)</span> <span class="nf">Watch</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">opts</span> <span class="nx">storage</span><span class="p">.</span><span class="nx">ListOptions</span><span class="p">)</span> <span class="p">(</span><span class="nx">watch</span><span class="p">.</span><span class="nx">Interface</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="o">...</span>
  
	<span class="nx">triggerValue</span><span class="p">,</span> <span class="nx">triggerSupported</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">indexedTrigger</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">field</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pred</span><span class="p">.</span><span class="nx">IndexFields</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">field</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">indexedTrigger</span><span class="p">.</span><span class="nx">indexName</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">pred</span><span class="p">.</span><span class="nx">Field</span><span class="p">.</span><span class="nf">RequiresExactMatch</span><span class="p">(</span><span class="nx">field</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
					<span class="nx">triggerValue</span><span class="p">,</span> <span class="nx">triggerSupported</span> <span class="p">=</span> <span class="nx">value</span><span class="p">,</span> <span class="kc">true</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// It boils down to a tradeoff between:
</span><span class="c1"></span>	<span class="c1">// - having it as small as possible to reduce memory usage
</span><span class="c1"></span>	<span class="c1">// - having it large enough to ensure that watchers that need to process
</span><span class="c1"></span>	<span class="c1">//   a bunch of changes have enough buffer to avoid from blocking other
</span><span class="c1"></span>	<span class="c1">//   watchers on our watcher having a processing hiccup
</span><span class="c1"></span>	<span class="nx">chanSize</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">watchCache</span><span class="p">.</span><span class="nf">suggestedWatchChannelSize</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">indexedTrigger</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">triggerSupported</span><span class="p">)</span>

	<span class="c1">// Determine a function that computes the bookmarkAfterResourceVersion
</span><span class="c1"></span>	<span class="nx">bookmarkAfterResourceVersionFn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">getBookmarkAfterResourceVersionLockedFunc</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">requestedWatchRV</span><span class="p">,</span> <span class="nx">opts</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">newErrWatcher</span><span class="p">(</span><span class="nx">err</span><span class="p">),</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// Determine a function that computes the watchRV we should start from
</span><span class="c1"></span>	<span class="nx">startWatchResourceVersionFn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">getStartResourceVersionForWatchLockedFunc</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">requestedWatchRV</span><span class="p">,</span> <span class="nx">opts</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">newErrWatcher</span><span class="p">(</span><span class="nx">err</span><span class="p">),</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// Determine watch timeout(&#39;0&#39; means deadline is not set, ignore checking)
</span><span class="c1"></span>	<span class="nx">deadline</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nf">Deadline</span><span class="p">()</span>

	<span class="nx">identifier</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;key: %q, labels: %q, fields: %q&#34;</span><span class="p">,</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">pred</span><span class="p">.</span><span class="nx">Label</span><span class="p">,</span> <span class="nx">pred</span><span class="p">.</span><span class="nx">Field</span><span class="p">)</span>

	<span class="c1">// Create a watcher here to reduce memory allocations under lock,
</span><span class="c1"></span>	<span class="c1">// given that memory allocation may trigger GC and block the thread.
</span><span class="c1"></span>	<span class="c1">// Also note that emptyFunc is a placeholder, until we will be able
</span><span class="c1"></span>	<span class="c1">// to compute watcher.forget function (which has to happen under lock).
</span><span class="c1"></span>	<span class="nx">watcher</span> <span class="o">:=</span> <span class="nf">newCacheWatcher</span><span class="p">(</span>
		<span class="nx">chanSize</span><span class="p">,</span>
		<span class="nf">filterWithAttrsFunction</span><span class="p">(</span><span class="nx">key</span><span class="p">,</span> <span class="nx">pred</span><span class="p">),</span>
		<span class="nx">emptyFunc</span><span class="p">,</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">versioner</span><span class="p">,</span>
		<span class="nx">deadline</span><span class="p">,</span>
		<span class="nx">pred</span><span class="p">.</span><span class="nx">AllowWatchBookmarks</span><span class="p">,</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">groupResource</span><span class="p">,</span>
		<span class="nx">identifier</span><span class="p">,</span>
	<span class="p">)</span>

	<span class="c1">// note that c.waitUntilWatchCacheFreshAndForceAllEvents must be called without
</span><span class="c1"></span>	<span class="c1">// the c.watchCache.RLock held otherwise we are at risk of a deadlock
</span><span class="c1"></span>	<span class="c1">// mainly because c.watchCache.processEvent method won&#39;t be able to make progress
</span><span class="c1"></span>	<span class="c1">//
</span><span class="c1"></span>	<span class="c1">// moreover even though the c.waitUntilWatchCacheFreshAndForceAllEvents acquires a lock
</span><span class="c1"></span>	<span class="c1">// it is safe to release the lock after the method finishes because we don&#39;t require
</span><span class="c1"></span>	<span class="c1">// any atomicity between the call to the method and further calls that actually get the events.
</span><span class="c1"></span>	<span class="nx">forceAllEvents</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">waitUntilWatchCacheFreshAndForceAllEvents</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">requestedWatchRV</span><span class="p">,</span> <span class="nx">opts</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nf">newErrWatcher</span><span class="p">(</span><span class="nx">err</span><span class="p">),</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="c1">// We explicitly use thread unsafe version and do locking ourself to ensure that
</span><span class="c1"></span>	<span class="c1">// no new events will be processed in the meantime. The watchCache will be unlocked
</span><span class="c1"></span>	<span class="c1">// on return from this function.
</span><span class="c1"></span>	<span class="c1">// Note that we cannot do it under cacher lock, to avoid a deadlock, since the
</span><span class="c1"></span>	<span class="c1">// underlying watchCache is calling processEvent under its lock.
</span><span class="c1"></span>	<span class="nx">c</span><span class="p">.</span><span class="nx">watchCache</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">watchCache</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>

	<span class="nx">startWatchRV</span> <span class="o">:=</span> <span class="nf">startWatchResourceVersionFn</span><span class="p">()</span>
	<span class="kd">var</span> <span class="nx">cacheInterval</span> <span class="o">*</span><span class="nx">watchCacheInterval</span>
	<span class="k">if</span> <span class="nx">forceAllEvents</span> <span class="p">{</span>
		<span class="nx">cacheInterval</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">watchCache</span><span class="p">.</span><span class="nf">getIntervalFromStoreLocked</span><span class="p">()</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">cacheInterval</span><span class="p">,</span> <span class="nx">err</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">watchCache</span><span class="p">.</span><span class="nf">getAllEventsSinceLocked</span><span class="p">(</span><span class="nx">startWatchRV</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// To match the uncached watch implementation, once we have passed authn/authz/admission,
</span><span class="c1"></span>		<span class="c1">// and successfully parsed a resource version, other errors must fail with a watch event of type ERROR,
</span><span class="c1"></span>		<span class="c1">// rather than a directly returned error.
</span><span class="c1"></span>		<span class="k">return</span> <span class="nf">newErrWatcher</span><span class="p">(</span><span class="nx">err</span><span class="p">),</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="nx">addedWatcher</span> <span class="o">:=</span> <span class="kc">false</span>
	<span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

		<span class="k">if</span> <span class="nx">generation</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">ready</span><span class="p">.</span><span class="nf">checkAndReadGeneration</span><span class="p">();</span> <span class="nx">generation</span> <span class="o">!=</span> <span class="nx">readyGeneration</span> <span class="o">||</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
			<span class="c1">// We went unready or are already on a different generation.
</span><span class="c1"></span>			<span class="c1">// Avoid registering and starting the watch as it will have to be
</span><span class="c1"></span>			<span class="c1">// terminated immediately anyway.
</span><span class="c1"></span>			<span class="k">return</span>
		<span class="p">}</span>

		<span class="c1">// Update watcher.forget function once we can compute it.
</span><span class="c1"></span>		<span class="nx">watcher</span><span class="p">.</span><span class="nx">forget</span> <span class="p">=</span> <span class="nf">forgetWatcher</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">watcher</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">watcherIdx</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">triggerValue</span><span class="p">,</span> <span class="nx">triggerSupported</span><span class="p">)</span>
		<span class="c1">// Update the bookMarkAfterResourceVersion
</span><span class="c1"></span>		<span class="nx">watcher</span><span class="p">.</span><span class="nf">setBookmarkAfterResourceVersion</span><span class="p">(</span><span class="nf">bookmarkAfterResourceVersionFn</span><span class="p">())</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">watchers</span><span class="p">.</span><span class="nf">addWatcher</span><span class="p">(</span><span class="nx">watcher</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">watcherIdx</span><span class="p">,</span> <span class="nx">scope</span><span class="p">,</span> <span class="nx">triggerValue</span><span class="p">,</span> <span class="nx">triggerSupported</span><span class="p">)</span>
		<span class="nx">addedWatcher</span> <span class="p">=</span> <span class="kc">true</span>

		<span class="c1">// Add it to the queue only when the client support watch bookmarks.
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">watcher</span><span class="p">.</span><span class="nx">allowWatchBookmarks</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">bookmarkWatchers</span><span class="p">.</span><span class="nf">addWatcherThreadUnsafe</span><span class="p">(</span><span class="nx">watcher</span><span class="p">)</span>
		<span class="p">}</span>
		<span class="nx">c</span><span class="p">.</span><span class="nx">watcherIdx</span><span class="o">++</span>
	<span class="p">}()</span>

	<span class="k">if</span> <span class="p">!</span><span class="nx">addedWatcher</span> <span class="p">{</span>
		<span class="c1">// Watcher isn&#39;t really started at this point, so it&#39;s safe to just drop it.
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// We&#39;re simulating the immediate watch termination, which boils down to simply
</span><span class="c1"></span>		<span class="c1">// closing the watcher.
</span><span class="c1"></span>		<span class="k">return</span> <span class="nf">newImmediateCloseWatcher</span><span class="p">(),</span> <span class="kc">nil</span>
	<span class="p">}</span>

	<span class="k">go</span> <span class="nx">watcher</span><span class="p">.</span><span class="nf">processInterval</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">cacheInterval</span><span class="p">,</span> <span class="nx">startWatchRV</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">watcher</span><span class="p">,</span> <span class="kc">nil</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>先计算 chan 缓冲区大小，然后实例化 cacheWatcher 对象，至此 watch 请求对应的服务端数据结构 cacheWatcher 也生成了。</p>
<p>cacher 是在 kube-apiserver 启动时就开始运行的，对应到 watch 请求的生命周期则是</p>
<ol>
<li>8）步入社会：从客户端请求开始，创建 cacheWatcher 并通过 <code>addWachter</code> 方法加入到 cacher.watchers 里面；</li>
<li>6）被 Push：加入到 cacher.watchers 后就不停地被 push；</li>
<li>7）干到干不动：启动一个 goroutine 调用 <code>processInterval</code> 来进行核心逻辑处理；</li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://www.likakuli.com/posts/cacher/cacher.svg"
        data-srcset="https://www.likakuli.com/posts/cacher/cacher.svg, https://www.likakuli.com/posts/cacher/cacher.svg 1.5x, https://www.likakuli.com/posts/cacher/cacher.svg 2x"
        data-sizes="auto"
        alt="https://www.likakuli.com/posts/cacher/cacher.svg"
        title="cacher" /></p>
<h3 id="小结">小结</h3>
<p>至此，已经介绍了从客户端发起请求，到服务端通过已经注册的路由和对应 handler 去创建新的 cacheWatcher，并消费 cacheWatcher 的 ResultChan 把最终的 event 序列化后写到 response 中的整个过程。</p>
<h1 id="干到干不动">干到干不动</h1>
<h2 id="三驾马车">三驾马车</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">cacheWatcher</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">input</span>     <span class="kd">chan</span> <span class="o">*</span><span class="nx">watchCacheEvent</span>
	<span class="nx">result</span>    <span class="kd">chan</span> <span class="nx">watch</span><span class="p">.</span><span class="nx">Event</span>
  <span class="nx">done</span>      <span class="kd">chan</span> <span class="kd">struct</span><span class="p">{}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>cacheWatcher 有三个 chan，其中 input 用来接收 cacher 发过来的 event，result 用来保存最终要返回的 event，上面提到的 <code>processInterval</code> 会消费 input 中的数据，发送到 result 中，done 用来控制是否还要往 result 中发送数据。前两个 chan 用来存放 event，是带缓冲的，缓冲的大小与资源类型以及 watchCache 的滑动窗口大小有关，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">w</span> <span class="o">*</span><span class="nx">watchCache</span><span class="p">)</span> <span class="nf">suggestedWatchChannelSize</span><span class="p">(</span><span class="nx">indexExists</span><span class="p">,</span> <span class="nx">triggerUsed</span> <span class="kt">bool</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="c1">// To estimate the channel size we use a heuristic that a channel
</span><span class="c1"></span>	<span class="c1">// should roughly be able to keep one second of history.
</span><span class="c1"></span>	<span class="c1">// We don&#39;t have an exact data, but given we store updates from
</span><span class="c1"></span>	<span class="c1">// the last &lt;eventFreshDuration&gt;, we approach it by dividing the
</span><span class="c1"></span>	<span class="c1">// capacity by the length of the history window.
</span><span class="c1"></span>	<span class="nx">chanSize</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Ceil</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">w</span><span class="p">.</span><span class="nf">currentCapacity</span><span class="p">())</span> <span class="o">/</span> <span class="nx">eventFreshDuration</span><span class="p">.</span><span class="nf">Seconds</span><span class="p">()))</span>

	<span class="c1">// Finally we adjust the size to avoid ending with too low or
</span><span class="c1"></span>	<span class="c1">// to large values.
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">chanSize</span> <span class="p">&lt;</span> <span class="nx">minWatchChanSize</span> <span class="p">{</span>
		<span class="nx">chanSize</span> <span class="p">=</span> <span class="nx">minWatchChanSize</span>
	<span class="p">}</span>
	<span class="kd">var</span> <span class="nx">maxChanSize</span> <span class="kt">int</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">indexExists</span> <span class="o">&amp;&amp;</span> <span class="nx">triggerUsed</span><span class="p">:</span>
		<span class="nx">maxChanSize</span> <span class="p">=</span> <span class="nx">maxWatchChanSizeWithIndexAndTrigger</span>
	<span class="k">case</span> <span class="nx">indexExists</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">triggerUsed</span><span class="p">:</span>
		<span class="nx">maxChanSize</span> <span class="p">=</span> <span class="nx">maxWatchChanSizeWithIndexWithoutTrigger</span>
	<span class="k">case</span> <span class="p">!</span><span class="nx">indexExists</span><span class="p">:</span>
		<span class="nx">maxChanSize</span> <span class="p">=</span> <span class="nx">maxWatchChanSizeWithoutIndex</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">chanSize</span> <span class="p">&gt;</span> <span class="nx">maxChanSize</span> <span class="p">{</span>
		<span class="nx">chanSize</span> <span class="p">=</span> <span class="nx">maxChanSize</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">chanSize</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>watchCache 滑动窗口大小从 <a href="https://github.com/kubernetes/kubernetes/pull/90091" target="_blank" rel="noopener noreffer">v1.19 开始支持动态调整</a>，初始值 100，最大 100 * 1024，chanSize 根据当前滑动窗口大小和 eventFreshDuration（从最初的 5m 调整到了最新的 75s）计算一个值，然后再根据传入的两个参数得到最大值，最终的 chanSize 介于最大值和最小值之间。传入的两个参数的计算逻辑如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">triggerValue</span><span class="p">,</span> <span class="nx">triggerSupported</span> <span class="o">:=</span> <span class="s">&#34;&#34;</span><span class="p">,</span> <span class="kc">false</span>
	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">indexedTrigger</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">field</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pred</span><span class="p">.</span><span class="nx">IndexFields</span> <span class="p">{</span>
			<span class="k">if</span> <span class="nx">field</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">indexedTrigger</span><span class="p">.</span><span class="nx">indexName</span> <span class="p">{</span>
				<span class="k">if</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">pred</span><span class="p">.</span><span class="nx">Field</span><span class="p">.</span><span class="nf">RequiresExactMatch</span><span class="p">(</span><span class="nx">field</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
					<span class="nx">triggerValue</span><span class="p">,</span> <span class="nx">triggerSupported</span> <span class="p">=</span> <span class="nx">value</span><span class="p">,</span> <span class="kc">true</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// It boils down to a tradeoff between:
</span><span class="c1"></span>	<span class="c1">// - having it as small as possible to reduce memory usage
</span><span class="c1"></span>	<span class="c1">// - having it large enough to ensure that watchers that need to process
</span><span class="c1"></span>	<span class="c1">//   a bunch of changes have enough buffer to avoid from blocking other
</span><span class="c1"></span>	<span class="c1">//   watchers on our watcher having a processing hiccup
</span><span class="c1"></span>	<span class="nx">chanSize</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">watchCache</span><span class="p">.</span><span class="nf">suggestedWatchChannelSize</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">indexedTrigger</span> <span class="o">!=</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">triggerSupported</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>这里是专门为 Pod 做的优化，<code>c.indexedTrigger</code> 只有当资源类型是 Pod 时才有值，indexName 为 <code>spec.nodeName</code>，indexerFunc 返回 <code>pod.spec.nodeName</code> 的值，其作用会在下文分析。最终 chanSize 的结果如下</p>
<ul>
<li>对于携带了 <code>fieldSelector=spec.nodeName=nodeA</code> 的 pod watch 请求（多来自 kubelet），其最终的 chanSize 固定为 10；</li>
<li>对于没有携带上述 fieldSelector 的 pod watch 请求，其最终的 chanSize 介于 10 ~ 1000；</li>
<li>对于其他非 pod 的 watch 请求，其最终的 chanSize 介于 10 ~ 100 之间；</li>
</ul>
<p>chanSize 会作为最终创建的 cacheWatcher 的 input 和 result chan 的缓冲区大小。</p>
<h2 id="辛苦劳碌">辛苦劳碌</h2>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="cacher_new.png"
        data-srcset="/posts/watchlife/cacher_new.png, cacher_new.png 1.5x, /posts/watchlife/cacher_new.png 2x"
        data-sizes="auto"
        alt="/posts/watchlife/cacher_new.png"
        title="cacher" /></p>
<ul>
<li>c）Push 数据到 input chan：cacheWatcher input 和 result chan 接受资源的 add，update，delete event，同时也接受自 v1.15 开始支持的 bookmark event；</li>
<li>a）把 initEvents 发送到 result chan：对于 watch 请求，如果 RV 不设置或者设置为 0，则从 <code>watchCache store</code> 返回 initEvents，否则只要其值不小于 watchCache 滑动窗口最老的 event 的 RV，则从 <code>watchCache</code> 滑动窗口返回 initEvents；</li>
<li>b）消费 input chan 并发送到 result chan：initEvents 发送完之后开始消费 input chan 中的数据；</li>
</ul>
<p>由于 cacheWatcher input chan 数据来自 cacher，所以下面的分析中也会对 cacher 相关逻辑进行分析，会标注功能所属，如前置过滤 - cacher 就代表 cacher 里面的功能。</p>
<h3 id="前置过滤---cacher">前置过滤 - cacher</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// startDispatching chooses watchers potentially interested in a given event
</span><span class="c1">// a marks dispatching as true.
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Cacher</span><span class="p">)</span> <span class="nf">startDispatching</span><span class="p">(</span><span class="nx">event</span> <span class="o">*</span><span class="nx">watchCacheEvent</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// It is safe to call triggerValuesThreadUnsafe here, because at this
</span><span class="c1"></span>    <span class="c1">// point only this thread can access this event (we create a separate
</span><span class="c1"></span>    <span class="c1">// watchCacheEvent for every dispatch).
</span><span class="c1"></span>    <span class="nx">triggerValues</span><span class="p">,</span> <span class="nx">supported</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">triggerValuesThreadUnsafe</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span>

    <span class="nx">c</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
    <span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>

    <span class="nx">c</span><span class="p">.</span><span class="nx">dispatching</span> <span class="p">=</span> <span class="kc">true</span>
    <span class="c1">// We are reusing the slice to avoid memory reallocations in every
</span><span class="c1"></span>    <span class="c1">// dispatchEvent() call. That may prevent Go GC from freeing items
</span><span class="c1"></span>    <span class="c1">// from previous phases that are sitting behind the current length
</span><span class="c1"></span>    <span class="c1">// of the slice, but there is only a limited number of those and the
</span><span class="c1"></span>    <span class="c1">// gain from avoiding memory allocations is much bigger.
</span><span class="c1"></span>    <span class="nx">c</span><span class="p">.</span><span class="nx">watchersBuffer</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">watchersBuffer</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nx">event</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">watch</span><span class="p">.</span><span class="nx">Bookmark</span> <span class="p">{</span>
       <span class="nx">c</span><span class="p">.</span><span class="nf">startDispatchingBookmarkEventsLocked</span><span class="p">()</span>
       <span class="c1">// return here to reduce following code indentation and diff
</span><span class="c1"></span>       <span class="k">return</span>
    <span class="p">}</span>

    <span class="c1">// iterate over watchers for each applicable namespace/name tuple
</span><span class="c1"></span>    <span class="nx">namespace</span> <span class="o">:=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">ObjFields</span><span class="p">[</span><span class="s">&#34;metadata.namespace&#34;</span><span class="p">]</span>
    <span class="nx">name</span> <span class="o">:=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">ObjFields</span><span class="p">[</span><span class="s">&#34;metadata.name&#34;</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">namespace</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
       <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
          <span class="c1">// namespaced watchers scoped by name
</span><span class="c1"></span>          <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">watcher</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">watchers</span><span class="p">.</span><span class="nx">allWatchers</span><span class="p">[</span><span class="nx">namespacedName</span><span class="p">{</span><span class="nx">namespace</span><span class="p">:</span> <span class="nx">namespace</span><span class="p">,</span> <span class="nx">name</span><span class="p">:</span> <span class="nx">name</span><span class="p">}]</span> <span class="p">{</span>
             <span class="nx">c</span><span class="p">.</span><span class="nx">watchersBuffer</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">watchersBuffer</span><span class="p">,</span> <span class="nx">watcher</span><span class="p">)</span>
          <span class="p">}</span>
       <span class="p">}</span>
       <span class="c1">// namespaced watchers not scoped by name
</span><span class="c1"></span>       <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">watcher</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">watchers</span><span class="p">.</span><span class="nx">allWatchers</span><span class="p">[</span><span class="nx">namespacedName</span><span class="p">{</span><span class="nx">namespace</span><span class="p">:</span> <span class="nx">namespace</span><span class="p">}]</span> <span class="p">{</span>
          <span class="nx">c</span><span class="p">.</span><span class="nx">watchersBuffer</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">watchersBuffer</span><span class="p">,</span> <span class="nx">watcher</span><span class="p">)</span>
       <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
       <span class="c1">// cluster-wide watchers scoped by name
</span><span class="c1"></span>       <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">watcher</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">watchers</span><span class="p">.</span><span class="nx">allWatchers</span><span class="p">[</span><span class="nx">namespacedName</span><span class="p">{</span><span class="nx">name</span><span class="p">:</span> <span class="nx">name</span><span class="p">}]</span> <span class="p">{</span>
          <span class="nx">c</span><span class="p">.</span><span class="nx">watchersBuffer</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">watchersBuffer</span><span class="p">,</span> <span class="nx">watcher</span><span class="p">)</span>
       <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// cluster-wide watchers unscoped by name
</span><span class="c1"></span>    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">watcher</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">watchers</span><span class="p">.</span><span class="nx">allWatchers</span><span class="p">[</span><span class="nx">namespacedName</span><span class="p">{}]</span> <span class="p">{</span>
       <span class="nx">c</span><span class="p">.</span><span class="nx">watchersBuffer</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">watchersBuffer</span><span class="p">,</span> <span class="nx">watcher</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">supported</span> <span class="p">{</span>
       <span class="c1">// Iterate over watchers interested in the given values of the trigger.
</span><span class="c1"></span>       <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">triggerValue</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">triggerValues</span> <span class="p">{</span>
          <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">watcher</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">watchers</span><span class="p">.</span><span class="nx">valueWatchers</span><span class="p">[</span><span class="nx">triggerValue</span><span class="p">]</span> <span class="p">{</span>
             <span class="nx">c</span><span class="p">.</span><span class="nx">watchersBuffer</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">watchersBuffer</span><span class="p">,</span> <span class="nx">watcher</span><span class="p">)</span>
          <span class="p">}</span>
       <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
       <span class="c1">// supported equal to false generally means that trigger function
</span><span class="c1"></span>       <span class="c1">// is not defined (or not aware of any indexes). In this case,
</span><span class="c1"></span>       <span class="c1">// watchers filters should generally also don&#39;t generate any
</span><span class="c1"></span>       <span class="c1">// trigger values, but can cause problems in case of some
</span><span class="c1"></span>       <span class="c1">// misconfiguration. Thus we paranoidly leave this branch.
</span><span class="c1"></span>
       <span class="c1">// Iterate over watchers interested in exact values for all values.
</span><span class="c1"></span>       <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">watchers</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">watchers</span><span class="p">.</span><span class="nx">valueWatchers</span> <span class="p">{</span>
          <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">watcher</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">watchers</span> <span class="p">{</span>
             <span class="nx">c</span><span class="p">.</span><span class="nx">watchersBuffer</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">watchersBuffer</span><span class="p">,</span> <span class="nx">watcher</span><span class="p">)</span>
          <span class="p">}</span>
       <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>c）是 cacher 的行为，发送之前会先调用 <code>startDispatching</code> 方法根据 <code>cacher.watchers</code> 和 event type 准备好要接收对应 event 的所有 cacheWatcher 放到 <code>c.watchersBuffer</code> 中。上一小节提到的 <code>indexedTrigger</code> 的作用就是减少特定情况下的需要遍历的 cacheWatcher 的数量，提升 cacher.incoming chan 的消费速度，因为他也是带缓冲的 chan，chan size 也是 100，而且也是在不停的接受来自 Etcd 的 event；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">watcher</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">watchersBuffer</span> <span class="p">{</span>
	  <span class="k">if</span> <span class="p">!</span><span class="nx">watcher</span><span class="p">.</span><span class="nf">nonblockingAdd</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
		    <span class="nx">c</span><span class="p">.</span><span class="nx">blockedWatchers</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">blockedWatchers</span><span class="p">,</span> <span class="nx">watcher</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>相当于提前根据 event 过滤掉了不关注此 event 的 cacheWatcher，这样上面的 for 循环需要遍历的次数就会降低，尤其是对带了 <code>spec.nodeName</code> 的来自 kubelet 的 watch 请求，一个非 bookmark event 里面的资源对象如果是已经调度成功的 pod 的话，他只需要发送到指定的一个 cacheWatcher 即可，而如果没有这个功能的话，他就得把这个 event 发送给所有 cacheWatcher，然后等到 b）消费 input 数据时再根据 filter 过滤掉不匹配的 event。</p>
<p>对于一个 5000 个 node 的集群来说，<code>c.watchersBuffer</code> 数量会从 5000 变成 1，同时数据也只往一个 cacheWatcher 的 input chan 发送，<strong>无论内存大小还是 cpu 消耗都是一个巨大的提升</strong>，如果没有这个功能的话，随着集群规模的提升，在 kube-apiserver 中会出现特别多 <code>Fast watcher, slow processing</code> 字样的日志（前提日志等级需要至少开到 3），这代表处理从 Etcd 读到的 event 太慢了，<code>watchChan</code> 的 <code>incomingEventChan</code> 或者 <code>resultChan</code> 缓冲区（都是 100）满了，导致客户端感知到的 event 出现延迟，同时由于从 Etcd 接受到的 event 无法及时处理都堆积在内存中，内存也会开始增加。</p>
<h3 id="控制-bookmark-频率---cacher">控制 bookmark 频率 - cacher</h3>
<p>bookmark event 是由 bookmark timer 定时发送的，来自 Etcd 的 progressNotify 所转换的 bookmark 并不会直接发送给所有的 cacheWatcher，只是更新 <code>lastProcessedResourceVersion</code>，代码如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cacher</span><span class="p">)</span> <span class="nf">dispatchEvents</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Jitter to help level out any aggregate load.
</span><span class="c1"></span>	<span class="nx">bookmarkTimer</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">clock</span><span class="p">.</span><span class="nf">NewTimer</span><span class="p">(</span><span class="nx">wait</span><span class="p">.</span><span class="nf">Jitter</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">))</span>
	<span class="k">defer</span> <span class="nx">bookmarkTimer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span>

	<span class="nx">lastProcessedResourceVersion</span> <span class="o">:=</span> <span class="nb">uint64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="k">for</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="nx">event</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">.</span><span class="nx">incoming</span><span class="p">:</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
				<span class="k">return</span>
			<span class="p">}</span>
			<span class="c1">// Don&#39;t dispatch bookmarks coming from the storage layer.
</span><span class="c1"></span>			<span class="c1">// They can be very frequent (even to the level of subseconds)
</span><span class="c1"></span>			<span class="c1">// to allow efficient watch resumption on kube-apiserver restarts,
</span><span class="c1"></span>			<span class="c1">// and propagating them down may overload the whole system.
</span><span class="c1"></span>			<span class="c1">//
</span><span class="c1"></span>			<span class="c1">// TODO: If at some point we decide the performance and scalability
</span><span class="c1"></span>			<span class="c1">// footprint is acceptable, this is the place to hook them in.
</span><span class="c1"></span>			<span class="c1">// However, we then need to check if this was called as a result
</span><span class="c1"></span>			<span class="c1">// of a bookmark event or regular Add/Update/Delete operation by
</span><span class="c1"></span>			<span class="c1">// checking if resourceVersion here has changed.
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">event</span><span class="p">.</span><span class="nx">Type</span> <span class="o">!=</span> <span class="nx">watch</span><span class="p">.</span><span class="nx">Bookmark</span> <span class="p">{</span>
				<span class="nx">c</span><span class="p">.</span><span class="nf">dispatchEvent</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">event</span><span class="p">)</span>
			<span class="p">}</span>
			<span class="nx">lastProcessedResourceVersion</span> <span class="p">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">ResourceVersion</span>
			<span class="nx">metrics</span><span class="p">.</span><span class="nx">EventsCounter</span><span class="p">.</span><span class="nf">WithLabelValues</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">groupResource</span><span class="p">.</span><span class="nf">String</span><span class="p">()).</span><span class="nf">Inc</span><span class="p">()</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">bookmarkTimer</span><span class="p">.</span><span class="nf">C</span><span class="p">():</span>
			<span class="nx">bookmarkTimer</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nx">wait</span><span class="p">.</span><span class="nf">Jitter</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">))</span>
			
      <span class="o">...</span>
      
			<span class="nx">bookmarkEvent</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">watchCacheEvent</span><span class="p">{</span>
				<span class="nx">Type</span><span class="p">:</span>            <span class="nx">watch</span><span class="p">.</span><span class="nx">Bookmark</span><span class="p">,</span>
				<span class="nx">Object</span><span class="p">:</span>          <span class="nx">c</span><span class="p">.</span><span class="nf">newFunc</span><span class="p">(),</span>
				<span class="nx">ResourceVersion</span><span class="p">:</span> <span class="nx">lastProcessedResourceVersion</span><span class="p">,</span>
			<span class="p">}</span>
			<span class="o">...</span>
			<span class="nx">c</span><span class="p">.</span><span class="nf">dispatchEvent</span><span class="p">(</span><span class="nx">bookmarkEvent</span><span class="p">)</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="nx">c</span><span class="p">.</span><span class="nx">stopCh</span><span class="p">:</span>
			<span class="k">return</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>注释写的很明确，不会直接把来自底层存储（Etcd）的 bookmark event 直接发给 cacheWatcher，代码里面也可以看到在消费 <code>c.incoming</code> 的时候有 event.Type 的判断，如果是 bookmark 的话，仅仅更新了 <code>lastProcessedResourceVersion</code> 属性。最终发给 cacheWatcher 的 bookmark 是通过 bookmarkTimer 定时触发的，<strong>每 1s ~ 1.25s 触发一次发送，每 1m 发一次 bookmark</strong>，这个地方很复杂，笔者觉得实现有问题，尤其是在开启 WatchList 的时候，还在和社区讨论，可以参考 <a href="https://github.com/kubernetes/kubernetes/issues/122277" target="_blank" rel="noopener noreffer">return a bookmark event with bookmarkafterresourceversion immediately to reduce WatchList time cost</a>，如果确认存在此问题的话，那么在 WatchList beta 之前这个问题是需要被解决的。涉及到的逻辑在上面展示的 <code>startDispatching</code> 方法中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">event</span><span class="p">.</span><span class="nx">Type</span> <span class="o">==</span> <span class="nx">watch</span><span class="p">.</span><span class="nx">Bookmark</span> <span class="p">{</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">startDispatchingBookmarkEventsLocked</span><span class="p">()</span>
    <span class="c1">// return here to reduce following code indentation and diff
</span><span class="c1"></span>		<span class="k">return</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>针对 bookmark event，会调用 <code>startDispatchingBookmarkEventsLocked</code> 筛选出来需要接收 bookmark event 的 cacheWatcher。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">cacher</span><span class="p">)</span> <span class="nf">startDispatchingBookmarkEventsLocked</span><span class="p">()</span> <span class="p">{</span>
	<span class="c1">// Pop already expired watchers. However, explicitly ignore stopped ones,
</span><span class="c1"></span>	<span class="c1">// as we don&#39;t delete watcher from bookmarkWatchers when it is stopped.
</span><span class="c1"></span>	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">watchers</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">bookmarkWatchers</span><span class="p">.</span><span class="nf">popExpiredWatchersThreadUnsafe</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">watcher</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">watchers</span> <span class="p">{</span>
			<span class="c1">// c.Lock() is held here.
</span><span class="c1"></span>			<span class="c1">// watcher.stopThreadUnsafe() is protected by c.Lock()
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">watcher</span><span class="p">.</span><span class="nx">stopped</span> <span class="p">{</span>
				<span class="k">continue</span>
			<span class="p">}</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">watchersBuffer</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">watchersBuffer</span><span class="p">,</span> <span class="nx">watcher</span><span class="p">)</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">expiredBookmarkWatchers</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">expiredBookmarkWatchers</span><span class="p">,</span> <span class="nx">watcher</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>startDispatchingBookmarkEventsLocked</code> 调用 <code>c.bookmarkWatchers</code> 的 <code>popExpiredWatchersThreadUnsafe</code> 找到所有需要发送 bookmark event 的 cacheWatcher，放到 <code>c.watchsBuffer</code> 中，就和普通的 event 一样。同时还要加入到 <code>c.expiredBookmarkWatchers</code> 中，在 <code>finishDispatching</code> 时重新把这些已经过期但没有 stop 的 cacheWatcher 重新加入到 <code>c.bookmarkWatchers</code> 中。</p>
<p><code>c.bookmarkWatchers</code> 的类型是 <code>watcherBookmarkTimeBuckets</code>，专门用来存储那些 query 中携带了 <code>allowWatchBookmarks=true</code>  的 watch 请求对应的 cacheWatcher。从有了 bookmark 开始，<code>watcherBookmarkTimeBuckets</code> 和其 <code>addWatcher</code> 方法进行过几次改动，梳理如下：</p>
<ol>
<li>
<p>v1.15 引入 bookmark 功能，<code>watcherBookmarkTimeBuckets.addWatcher</code> 会根据 cacheWatcher 的超时时间 - 2s 计算一个发送 bookmark event 的时间，然后根据这个时间戳，放到 <code>watcherBookmarkTimeBuckets</code> 里面。然后每 1s ~ 1.25s 通过 <code>popExpiredWatchersThreadUnsafe</code> 去获取需要发送 bookmark event 的 cacheWatcher，然后将生成的 bookmark event 发送给这些 cacheWatcher。此阶段在消费 <code>c.incoming</code> chan 时并没有判断 event type，因为此时并没有 progressNotify 的功能，所以 <code>c.incoming</code> chan 里面也就没有 bookmark event。这个阶段 bookmark event 发送时机是 watch 请求过期的前两秒，因为定期发送周期为 1s ~ 1.25s 所以在因为超时断开连接之前是可以发送一次 bookmark event 回去的；</p>
</li>
<li>
<p>V1.16 通过 <a href="https://github.com/kubernetes/kubernetes/pull/80692/" target="_blank" rel="noopener noreffer">Pop expired watchers in case there is no update to cache</a> 修复了 v1.15 中 bookmark 功能引入的一个 kube&ndash;apiserver 内存泄露的问题，在 cacher incoming chan 中没有 event 时，<code>lastProcessedResourceVersion</code> 一直是 0，在 bookmark timer 处理逻辑如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">lastProcessedResourceVersion</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
     <span class="k">continue</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>就会造成客户端每发起一次 watch 请求，服务端生成的 cacheWatcher 都添加到了 <code>watcherBookmarkTimeBuckets</code> 里面，即使 watch 连接关闭了，对应的 cacheWather 也还在内存中无法释放，造成内存泄露，修复方式如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">lastProcessedResourceVersion</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
    <span class="c1">// pop expired watchers in case there has been no update
</span><span class="c1"></span>     <span class="nx">c</span><span class="p">.</span><span class="nx">bookmarkWatchers</span><span class="p">.</span><span class="nf">popExpiredWatchers</span><span class="p">()</span>
     <span class="k">continue</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>v1.19 通过 <a href="https://github.com/kubernetes/kubernetes/pull/90560/" target="_blank" rel="noopener noreffer">Send watch bookmarks every minute</a> 修改了发送逻辑，由只在超时前两秒发送一次 bookmark 改为每分钟发送一次 bookmark，同时在超时前两秒也会发送一次；</p>
</li>
<li>
<p>v1.20 开始支持 ProgressNotify 功能，Etcd 发送回来的 progressNotify event 会被当做 bookmark event 发送到 cacher incoming chan 中，同时在消费 cacher incoming 的时候加了 event type 的判断，只处理非 bookmark event，bookmark event 统一通过 bookmark timer 生成，并发送给 cacheWatcher；</p>
</li>
<li>
<p>v1.28 通过 <a href="https://github.com/kubernetes/kubernetes/pull/119207" target="_blank" rel="noopener noreffer">Implement conditionalProgressRequester that allows requesting watch progress notification if watch cache is not fresh</a> 解决了 List 请求存在的 <a href="https://mp.weixin.qq.com/s/SMnKpnP5J07HBeG35oC9WQ" target="_blank" rel="noopener noreffer">Stale Read</a> 的问题。在执行 List 时，如果 cacher 最大 RV 还没达到 Etcd 最新 RV 时，会启动一个 goroutine 每 100ms 通过 <code>RequestProgress</code> 方法请求 Etcd 发送 ProgressNotify event 回来，在收到最新数据后停止调用 <code>RequestProgress</code>。这个时候会频繁的出现 bookmark event 发送到 cacher incoming chan，但由于 4 已经做了处理，所以这些 bookmark event 并不会直接写到 cacheWatcher input chan；</p>
</li>
<li>
<p>v1.28 通过 <a href="https://github.com/kubernetes/kubernetes/pull/117014" target="_blank" rel="noopener noreffer">cacher: do not simply popExpiredWatchers when the cacher hasn&rsquo;t dispatched any event</a> 修复了一个特定情况下 bookmark 功能失效的 bug，这个 bug 和第 2, 3 步有关，也就是说在 v1.19 ~ v1.27 中存在这个问题，但由于 bookmark 在此阶段属于锦上添花的功能，并不影响数据获取，所以即使有问题，外部也感知不到。其问题在于步骤 2 中通过引入 <code>popExpiredWatchers</code> 方法来清理过期的 cacheWatcher，如果在 watch 持续一分钟后一直没有任何事件到来，也就是 <code>lastProcessedResourceVersion</code> 是 0，就会命中 <code>popExpiredWatchers</code> 的逻辑就会把 cacheWatcher 从 <code>watcherBookmarkTimeBuckets</code> 删除，之后就算有事件到来，生成一个 bookmark event 对象，去获取需要发送的 cacheWatcher 的时候由于其已经被删除，所以就不会发送给这些 cacheWatcher 了。修方方式就是重新把没有 stop 的 cacheWatcher 加回去。这个问题能被发现得益于 <a href="https://mp.weixin.qq.com/s/futHT0njb5y2UHLeg7BL7w" target="_blank" rel="noopener noreffer">WatchList</a>，因为 WatchList 把 bookmark 从一个锦上添花的功能提升到了核心功能，依赖携带指定 Annotation 的 bookmark 告诉客户端已经返回了全量数据了。</p>
</li>
</ol>
<h3 id="及时消费">及时消费</h3>
<p>input chan 在 cacheWatcher 创建之后就开始写数据，而消费则需要等待 initEvent 发送完之后才开始，所以就有可能在 c）往 input 发数据时，input chan 缓冲区已经满了的情况。为什么我们几乎没有发觉这个问题呢，那是因为 client-go 使用 ListWatch 的方式会先通过 List 获得最新的 RV，然后带着这个 RV 去 Watch，所以 initEvent 的数量会比较少。但这个机制的问题在开启 WatchList 时就会凸显出来，当要返回的数据量较大时，因为都是通过 Watch 实现的，input chan 在被消费之前就被写满的概率就会大大提升，如果阻塞时间较长（超过 100ms）就会被强制关闭，有一定的副作用，会在下文深入分析。在 WatchList 成为 beta 之前，这个问题是必须要解决的。</p>
<h1 id="怎么没滴">怎么没滴</h1>
<p>Watch 请求有如下几种结束条件：</p>
<ul>
<li>异常退出：客户端或者服务端 crash；</li>
<li>超时：客户端在发起 watch 请求时会设置 <code>timeoutseconds</code> 参数，同时服务端也有个默认值，优先使用客户端设置的值
<ul>
<li>client-go informer 发起的 watch 请求，默认 5m ~ 10m 超时；</li>
<li>kube-apiserver 通过 <code>--min-request-timeout</code> 控制，默认为 1800，即 30m ~ 60m 超时；</li>
</ul>
</li>
<li>cacher 为 cacheWatcher 分发 event 阻塞太长时间；</li>
</ul>
<p>前两种好理解，下面主要讲第三种，涉及到的逻辑较复杂，通过控制 chan 实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">		<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">watcher</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">watchersBuffer</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">!</span><span class="nx">watcher</span><span class="p">.</span><span class="nf">nonblockingAdd</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
				<span class="nx">c</span><span class="p">.</span><span class="nx">blockedWatchers</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">blockedWatchers</span><span class="p">,</span> <span class="nx">watcher</span><span class="p">)</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">blockedWatchers</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="c1">// dispatchEvent is called very often, so arrange
</span><span class="c1"></span>			<span class="c1">// to reuse timers instead of constantly allocating.
</span><span class="c1"></span>			<span class="nx">startTime</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
			<span class="nx">timeout</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dispatchTimeoutBudget</span><span class="p">.</span><span class="nf">takeAvailable</span><span class="p">()</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">timer</span><span class="p">.</span><span class="nf">Reset</span><span class="p">(</span><span class="nx">timeout</span><span class="p">)</span>

			<span class="c1">// Send event to all blocked watchers. As long as timer is running,
</span><span class="c1"></span>			<span class="c1">// `add` will wait for the watcher to unblock. After timeout,
</span><span class="c1"></span>			<span class="c1">// `add` will not wait, but immediately close a still blocked watcher.
</span><span class="c1"></span>			<span class="c1">// Hence, every watcher gets the chance to unblock itself while timer
</span><span class="c1"></span>			<span class="c1">// is running, not only the first ones in the list.
</span><span class="c1"></span>			<span class="nx">timer</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">timer</span>
			<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">watcher</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">c</span><span class="p">.</span><span class="nx">blockedWatchers</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">!</span><span class="nx">watcher</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nx">event</span><span class="p">,</span> <span class="nx">timer</span><span class="p">)</span> <span class="p">{</span>
					<span class="c1">// fired, clean the timer by set it to nil.
</span><span class="c1"></span>					<span class="nx">timer</span> <span class="p">=</span> <span class="kc">nil</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="c1">// Stop the timer if it is not fired
</span><span class="c1"></span>			<span class="k">if</span> <span class="nx">timer</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">timer</span><span class="p">.</span><span class="nf">Stop</span><span class="p">()</span> <span class="p">{</span>
				<span class="c1">// Consume triggered (but not yet received) timer event
</span><span class="c1"></span>				<span class="c1">// so that future reuse does not get a spurious timeout.
</span><span class="c1"></span>				<span class="o">&lt;-</span><span class="nx">timer</span><span class="p">.</span><span class="nx">C</span>
			<span class="p">}</span>

			<span class="nx">c</span><span class="p">.</span><span class="nx">dispatchTimeoutBudget</span><span class="p">.</span><span class="nf">returnUnused</span><span class="p">(</span><span class="nx">timeout</span> <span class="o">-</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">startTime</span><span class="p">))</span>
		<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>依赖 <code>dispatchTimeoutBudget</code> 实现对第一次发送失败（input chan 满了）的 cacheWatcher 重新发送的能力。<code>dispatchTimeoutBudget</code> 类似内核中的 cpu burst 的控制逻辑，第一次分配 100ms 的等待时长，如果用完了，那么剩下所有的 input chan 仍然满着的 cacheWatcher 都会被关闭，如果在 100ms 内都发送成功了，那么会把还没有消耗的时间返回回去供下次使用，也就是说下次就会有大于 100ms 的等待时长可用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">		<span class="c1">// we are graceful = false, when:
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// (a) The bookmarkAfterResourceVersionReceived hasn&#39;t been received,
</span><span class="c1"></span>		<span class="c1">//     we can safely terminate the watcher. Because the client is waiting
</span><span class="c1"></span>		<span class="c1">//     for this specific bookmark, and we even haven&#39;t received one.
</span><span class="c1"></span>		<span class="c1">// (b) We have seen the bookmarkAfterResourceVersion, and it was sent already to the client.
</span><span class="c1"></span>		<span class="c1">//     We can simply terminate the watcher.
</span><span class="c1"></span>
		<span class="c1">// we are graceful = true, when:
</span><span class="c1"></span>		<span class="c1">//
</span><span class="c1"></span>		<span class="c1">// (a) We have seen a bookmark, but it hasn&#39;t been sent to the client yet.
</span><span class="c1"></span>		<span class="c1">//     That means we should drain the input buffer which contains
</span><span class="c1"></span>		<span class="c1">//     the bookmarkAfterResourceVersion we want. We do that to make progress
</span><span class="c1"></span>		<span class="c1">//     as clients can re-establish a new watch with the given RV and receive
</span><span class="c1"></span>		<span class="c1">//     further notifications.
</span><span class="c1"></span>		<span class="nx">graceful</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">bool</span> <span class="p">{</span>
			<span class="nx">c</span><span class="p">.</span><span class="nx">stateMutex</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
			<span class="k">defer</span> <span class="nx">c</span><span class="p">.</span><span class="nx">stateMutex</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
			<span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">cacheWatcherBookmarkReceived</span>
		<span class="p">}()</span>
		<span class="nx">klog</span><span class="p">.</span><span class="nf">V</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="nf">Infof</span><span class="p">(</span><span class="s">&#34;Forcing %v watcher close due to unresponsiveness: %v. len(c.input) = %v, len(c.result) = %v, graceful = %v&#34;</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">groupResource</span><span class="p">.</span><span class="nf">String</span><span class="p">(),</span> <span class="nx">c</span><span class="p">.</span><span class="nx">identifier</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">input</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">result</span><span class="p">),</span> <span class="nx">graceful</span><span class="p">)</span>
		<span class="nx">c</span><span class="p">.</span><span class="nf">forget</span><span class="p">(</span><span class="nx">graceful</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>通过 <code>c.forget</code> 实现关闭的效果，分两种情况：</p>
<ol>
<li>如果开启了 WatchList 且 cacheWatcher 已经收到了来自 cacher 的特殊 bookmark 且还没有发送给 result chan 的话，则进行优雅关闭，只是关闭了 input chan 不再接收 cacher 的数据，并不会关闭 done，也即是还可以执行消费 input 并发送到 result 的过程；</li>
<li>其他情况直接关闭 input 和 done，既不往 input 发送数据，也不再消费 input 往 result chan 发数据；</li>
</ol>
<p>从各种 watchers slice 中删除对应 cacheWatcher，最后执行 <code>processInterval</code> 方法的 goroutine 结束运行，并关闭 result chan。WatchServer 在 <code>HandleHTTP</code> 方法中判断 result chan 关闭，消费完里面的数据后整个 handler 执行完毕。至此，watch 请求走完了他的一生。</p>
</div><div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    <label class="qr-code-image" for="reward">
        <img class="image" src="/media/reward/wechat.jpg">
        <span>微信打赏</span>
      </label>
    
  </div>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2023-12-27</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://www.likakuli.com/posts/watchlife/" data-title="一条 Watch 请求的一生" data-hashtags="kubernetes"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://www.likakuli.com/posts/watchlife/" data-hashtag="kubernetes"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 WhatsApp" data-sharer="whatsapp" data-url="https://www.likakuli.com/posts/watchlife/" data-title="一条 Watch 请求的一生" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="https://www.likakuli.com/posts/watchlife/" data-title="一条 Watch 请求的一生"><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://www.likakuli.com/posts/watchlife/" data-title="一条 Watch 请求的一生"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Myspace" data-sharer="myspace" data-url="https://www.likakuli.com/posts/watchlife/" data-title="一条 Watch 请求的一生" data-description=""><i data-svg-src="https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/myspace.svg"></i></a><a href="javascript:void(0);" title="分享到 Blogger" data-sharer="blogger" data-url="https://www.likakuli.com/posts/watchlife/" data-title="一条 Watch 请求的一生" data-description=""><i class="fab fa-blogger fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Evernote" data-sharer="evernote" data-url="https://www.likakuli.com/posts/watchlife/" data-title="一条 Watch 请求的一生"><i class="fab fa-evernote fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/kubernetes/">kubernetes</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/connection/" class="prev" rel="prev" title="kube-apiserver 连接数也会影响内存？"><i class="fas fa-angle-left fa-fw"></i>kube-apiserver 连接数也会影响内存？</a>
            <a href="/posts/k8sparams/" class="next" rel="next" title="k8s: 到底谁才是草台班子？">k8s: 到底谁才是草台班子？<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="valine" class="comment"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://valine.js.org/">Valine</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.88.1">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2018 - 2024</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">kaku</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/valine/valine.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.css"><script type="text/javascript" src="https://polyfill.io/v3/polyfill.min.js?features=Array.prototype.fill%2CArray.prototype.find%2CArray.from%2CIntersectionObserver%2CMath.sign%2CObject.assign%2CPromise%2CObject.entries%2CElement.prototype.closest%2CrequestAnimationFrame%2CCustomEvent%2Chtml5shiv%2CObject.values%2Cfetch%2CElement.prototype.after"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/object-fit-images@3.2.4/dist/ofi.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.2.0/dist/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/twemoji@13.0.0/dist/twemoji.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/js/lightgallery.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lg-thumbnail.js@1.2.0/dist/lg-thumbnail.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lg-zoom.js@1.2.0/dist/lg-zoom.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/copy-tex.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{"valine":{"appId":"jR3DqfbcO7kal9wBOdhcpYgx-gzGzoHsz","appKey":"p3vIbO2osYNG5viDCFifFS1m","avatar":"mp","el":"#valine","emojiCDN":"https://cdn.jsdelivr.net/npm/emoji-datasource-google@5.0.1/img/google/64/","emojiMaps":{"100":"1f4af.png","alien":"1f47d.png","anger":"1f4a2.png","angry":"1f620.png","anguished":"1f627.png","astonished":"1f632.png","black_heart":"1f5a4.png","blue_heart":"1f499.png","blush":"1f60a.png","bomb":"1f4a3.png","boom":"1f4a5.png","broken_heart":"1f494.png","brown_heart":"1f90e.png","clown_face":"1f921.png","cold_face":"1f976.png","cold_sweat":"1f630.png","confounded":"1f616.png","confused":"1f615.png","cry":"1f622.png","crying_cat_face":"1f63f.png","cupid":"1f498.png","dash":"1f4a8.png","disappointed":"1f61e.png","disappointed_relieved":"1f625.png","dizzy":"1f4ab.png","dizzy_face":"1f635.png","drooling_face":"1f924.png","exploding_head":"1f92f.png","expressionless":"1f611.png","face_vomiting":"1f92e.png","face_with_cowboy_hat":"1f920.png","face_with_hand_over_mouth":"1f92d.png","face_with_head_bandage":"1f915.png","face_with_monocle":"1f9d0.png","face_with_raised_eyebrow":"1f928.png","face_with_rolling_eyes":"1f644.png","face_with_symbols_on_mouth":"1f92c.png","face_with_thermometer":"1f912.png","fearful":"1f628.png","flushed":"1f633.png","frowning":"1f626.png","ghost":"1f47b.png","gift_heart":"1f49d.png","green_heart":"1f49a.png","grimacing":"1f62c.png","grin":"1f601.png","grinning":"1f600.png","hankey":"1f4a9.png","hear_no_evil":"1f649.png","heart":"2764-fe0f.png","heart_decoration":"1f49f.png","heart_eyes":"1f60d.png","heart_eyes_cat":"1f63b.png","heartbeat":"1f493.png","heartpulse":"1f497.png","heavy_heart_exclamation_mark_ornament":"2763-fe0f.png","hole":"1f573-fe0f.png","hot_face":"1f975.png","hugging_face":"1f917.png","hushed":"1f62f.png","imp":"1f47f.png","innocent":"1f607.png","japanese_goblin":"1f47a.png","japanese_ogre":"1f479.png","joy":"1f602.png","joy_cat":"1f639.png","kiss":"1f48b.png","kissing":"1f617.png","kissing_cat":"1f63d.png","kissing_closed_eyes":"1f61a.png","kissing_heart":"1f618.png","kissing_smiling_eyes":"1f619.png","laughing":"1f606.png","left_speech_bubble":"1f5e8-fe0f.png","love_letter":"1f48c.png","lying_face":"1f925.png","mask":"1f637.png","money_mouth_face":"1f911.png","nauseated_face":"1f922.png","nerd_face":"1f913.png","neutral_face":"1f610.png","no_mouth":"1f636.png","open_mouth":"1f62e.png","orange_heart":"1f9e1.png","partying_face":"1f973.png","pensive":"1f614.png","persevere":"1f623.png","pleading_face":"1f97a.png","pouting_cat":"1f63e.png","purple_heart":"1f49c.png","rage":"1f621.png","relaxed":"263a-fe0f.png","relieved":"1f60c.png","revolving_hearts":"1f49e.png","right_anger_bubble":"1f5ef-fe0f.png","robot_face":"1f916.png","rolling_on_the_floor_laughing":"1f923.png","scream":"1f631.png","scream_cat":"1f640.png","see_no_evil":"1f648.png","shushing_face":"1f92b.png","skull":"1f480.png","skull_and_crossbones":"2620-fe0f.png","sleeping":"1f634.png","sleepy":"1f62a.png","slightly_frowning_face":"1f641.png","slightly_smiling_face":"1f642.png","smile":"1f604.png","smile_cat":"1f638.png","smiley":"1f603.png","smiley_cat":"1f63a.png","smiling_face_with_3_hearts":"1f970.png","smiling_imp":"1f608.png","smirk":"1f60f.png","smirk_cat":"1f63c.png","sneezing_face":"1f927.png","sob":"1f62d.png","space_invader":"1f47e.png","sparkling_heart":"1f496.png","speak_no_evil":"1f64a.png","speech_balloon":"1f4ac.png","star-struck":"1f929.png","stuck_out_tongue":"1f61b.png","stuck_out_tongue_closed_eyes":"1f61d.png","stuck_out_tongue_winking_eye":"1f61c.png","sunglasses":"1f60e.png","sweat":"1f613.png","sweat_drops":"1f4a6.png","sweat_smile":"1f605.png","thinking_face":"1f914.png","thought_balloon":"1f4ad.png","tired_face":"1f62b.png","triumph":"1f624.png","two_hearts":"1f495.png","unamused":"1f612.png","upside_down_face":"1f643.png","weary":"1f629.png","white_frowning_face":"2639-fe0f.png","white_heart":"1f90d.png","wink":"1f609.png","woozy_face":"1f974.png","worried":"1f61f.png","yawning_face":"1f971.png","yellow_heart":"1f49b.png","yum":"1f60b.png","zany_face":"1f92a.png","zipper_mouth_face":"1f910.png","zzz":"1f4a4.png"},"enableQQ":true,"highlight":true,"lang":"zh-cn","pageSize":10,"placeholder":"你的评论 ...","recordIP":true,"visitor":true}},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"V5KLQ7KY3O","algoliaIndex":"likakuli.com","algoliaSearchKey":"0059ae9418c944729d3c056aeda34e3a","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"twemoji":true};</script><script type="text/javascript" src="/js/theme.min.js"></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', 'UA-118805314-2', { 'anonymize_ip': true });
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=UA-118805314-2" async></script></body>
</html>
